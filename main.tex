% !TEX encoding = UTF-8 Unicode
% -*- coding: UTF-8; -*-
% vim: set fenc=utf-8


\documentclass{tktltiki}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}



% Kuvien numerointi Luvun mukaan
\usepackage{chngcntr}
\counterwithin{figure}{section}




\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}



\usepackage{epsfig}
\usepackage{subfigure}
\usepackage{url}



\usepackage{xcolor}
\usepackage{listings}% http://ctan.org/pkg/listings
\input{code/languageDefinitions}

\renewcommand\lstlistingname{Listaus}
\renewcommand\lstlistlistingname{Listaukset}



\begin{document}
%\doublespacing  joskus halutaan enemmän kommentointitilaa rivien väliin
%\onehalfspacing joskus halutaan enemmän kommentointitilaa rivien väliin
\singlespacing

\title{Progressiivisten web-sovelluksien kehittäminen}
\author{Niki Ahlskog}

\date{\today}

\maketitle

\numberofpagesinformation{\numberofpages\ sivua + \numberofappendixpages\ liitesivua}

\classification{\protect{\ \\
\  General and reference $\rightarrow$ Document types  $\rightarrow$ Surveys and overviews\  \\
\  Applied computing  $\rightarrow$ Document management and text processing  $\rightarrow$ Document management  $\rightarrow$ Text editing\ }}



\keywords{PWA, Progressiiviset web sovellukset, mobiili selainsovellus, progressiivisuus}

\begin{abstract}

Mobiilisovellukset ovat jatkuvasti kehittyvää ja muuttuvaa teknologiaa, kuten myös strategiat niiden rakentamiseksi. Tässä työssä käydään läpi Progressiivisen Web-sovelluksen (PWA) rakennustekniikoita. PWA:n tarkoitus on hämärtää, tai jopa poistaa raja ladattavan sovelluksen ja normaalin verkkosivuston välillä. Lisäksi tarkastellaan tekniikoiden vaikutuksia loppukäyttäjille käytännössä.

PWA on kuin mikä tahansa normaali verkkosivusto, mutta se täyttää lisäksi seuraavat kriteerit. Sovellus skaalautuu mille tahansa laitteelle. Sovellus tarjoillaan salatun yhteyden yli. Sovellus on mahdollista asentaa puhelimen kotinäytölle pikakuvakkeeksi, jolloin sovellus avautuu ilman selaimesta tuttuja navigointityökaluja ja lisäksi sovelluksen voi myös avata laitteen ollessa offline tilassa. 

PWA sovelluksen luomista ja käyttöönottoa tarkastellaan olemassa olevassa yksityisessä asiakasprojektissa. Projektissa kiinnitetään huomiota PWA-mallin tuomiin etuihin ja kipupisteisiin. Lisäksi kirjallisuuskatsauksen kautta tarkastellaan PWA:n tulevaisuuden näkymiä ja nykytilannetta. 

Asiakasprojektista otetaan Google Chromen Lighthouse työkalua käyttäen metriikat sovelluksen nopeuden mittaamiseksi. Nopeuden muutosta tarkastellaan progressiivisten ominaisuuksien ollessa käytössä ja niiden ollessa pois päältä. Lisäksi tarkastellaan mobiililaitteiden käyttöä koko sovelluksen käytössä. Analytiikat sovelluksen mobiilikäytöstä saadaan Google Analytics työkalusta. \end{abstract}

\mytableofcontents

\section{Johdanto}

Tämän päivän mobiilisovelluksia kehitettäessä on teknologia puolella useita vaihtoehtoja. Kehittäjät voivat valita ainakin neljästä eri mallista: mobiili web-sovellus, natiivisovellus, hybridisovellus, tai uusimpana Progressiivinen Web-sovellus (Progressive Web App), PWA. Jokaisessa vaihtoehdossa on luonnollisesti etuja ja haittoja. Web tekniikoihin panostaminen näyttäisi kuitenkin olevan järkevää, sillä nykyiset sovelluskaupat on jaettu eri laitealustojen kesken. Googlen julkaiseman tiedotteen mukaan [Gambhir] PWA sovellus käyttää moderneja web-tekniikoita saavuttaakseen sovelluksen kaltaisen käytöksen. Kun PWA malliin on tutustunut, natiivisovelluskehitystä ei enää tarvita. Mobiili verkkosivu itsessään muodostuu sovellukseksi käyttäen verkon parhaita tekniikoita. PWA sovellus on siis tavallinen verkkosivu, joka hyödyntää selainten uusimpia ominaisuuksia.

Progressiivisen Web-sovelluksen, eli PWA termin määritteli Google Chromen insinööri Alex Russel [Russell] omassa blogikirjoituksessaan vuonna 2015. PWA voidaan määritellä Alex Russelin sanoin normaaliksi verkkosivuksi, joka on vain ottanut oikeat vitamiinit. Yahoo Developer portaalissa tehdyn tutkimuksen mukaan [Khalaf] 90\% mobiililaitteilla vietetystä ajasta käytetään sovellusten parissa ja vain 10\% netin selaamiseen. 

Progressiivisten Web-sovellusten tarkoitus on hämärtää verkkosovellusten ja natiivisovellusten rajaa. Lisäksi PWA sovellusten etuna on, että IOS- ja Android alustoille ei tarvitse erikseen kehittää sovellusta ja ylläpitää kahta eri lähdekoodia. Yksi ja sama ohjelma riittää kummallekin alustalle. PWA ei siis ole uusi teknologia, eikä ohjelmointikehys. PWA on verkkosivu, tai web-selaimella toimiva sovellus, joka muistuttaa mahdollisimman paljon natiivia mobiili-, tai työpöytäsovellusta. Perimmäisenä ajatuksena on, että käyttäjä ei tunnista eroa näiden kahden sovelluksen välillä.

PWA sovelluksia ei paketoida, eikä jaella minkään sovelluskaupan kautta, ainakaan vielä, sillä ne ovat normaaleita verkkosivuja, joihin on tuotu progressiivisia ominaisuuksia. Alex  Russelin ajatuksena [Russell] PWA sovelluksissa on ollut niiden muotoutuminen sovellukseksi ilman, että käyttäjän tulee heti tehdä päätös sovelluksen asentamisesta ja käyttölupien luovuttamisesta. Esimerkiksi selaimista tuttu lupien kysyminen pysyy ennallaan. Sovellus kysyy mikrofonin, kameran, tai minkä tahansa muun ominaisuuden käyttölupaa vasta kun toimintoa tarvitaan ensimmäisen kerran. Muutaman käyttökerran jälkeen sovellus kysyy käyttäjältä, halutaanko puhelimen työpöydälle asentaa pikakuvake sovellukseen, ja ilmoituksetkin voidaan joko hyväksyä tai hylätä pyynnöstä. Tämä siis tarkoittaa että käytön myötä verkkosivu muuttuu käyttäjän puhelimessa natiivin mobiilisovelluksen kaltaiseksi ilman suurempaa sitoutumista sovelluksen asentamiseen ja kaikkien käyttölupien luovuttamiseen heti. 

PWA:ta kehitetään tällä hetkellä kovaa vauhtia eri selainvalmistajien toimesta. Firefoxilla ja Safarilla teknologia on tulossa [Santoni], ja Chromella se on pääosin jo tuettuna. 

PWA sovellukset eivät kuitenkaan sovellu sellaisiin käyttötarkoituksiin, joissa täytyy päästä käsiksi puhelimen rajapintoihin, kuten vaikkapa kalenteriin, tai osoitekirjaan. PWA:n valintaan vaikuttaa siis sovelluksen käyttötarkoitus. Tämän työn asiakasprojektissa, joka on IoT pohjainen web-sovellus, valittiin toteutustekniikaksi PWA, koska se ei vaadi erillistä kehittämistä eri laitealustoille, eikä projektissa ollut tarvetta käyttää puhelimeen sidottuja rajapintoja.

Tässä tutkielmassa selvitetään millaisia vaikutuksia progressiivisuudella saavutetaan ja kuinka helppoa työkalujen käyttöönotto on. Esimerkin projektissa mitataan sovelluksen nopeutta välimuistitallennuksen ollessa käytössä, sekä ilman. Mittarina käytetään Google-Chrome selaimen kehittäjätyökaluissa toimitettavaa Lighthouse työkalua. Lisäksi sovelluksen kehittäjä arvioi työkalujen käyttöönottoa noin muutaman vuoden ikäisessä projektissa. 

Tutkielman rakenne on seuraava. Luvussa 2 esitellään progressiivisten Web-sovelluksien vaatimukset, toteutustekniikoita ja selvennetään mitä koko termillä tarkoitetaan. Luvussa tarkastellaan myös muita mobiilikehitys tekniikoita ja teknologioita. Luvussa 3 käydään läpi tutkimusongelma ja luvussa 4 tehdään sovellukseen tekninen toteutus. Projektissa asennetaan tarvittavat työkalut PWA-mallin täyttämiseksi. Luvussa 5 suoritetaan nopeusmittaukset käyttämällä Google-Chrome selaimen Lighthouse työkalua ja arvioidaan kuinka paljon vaikutuksia progressiivisilla ominaisuuksilla oli sovelluksen nopeuteen. Luvussa myös arvioidaan PWA:ta toteustekniikkana. Luvussa 6 tehdään yhteenveto.

\newpage
\section{PWA:n esittely}

PWA ei ole ohjelmistokehys tai uusi teknologia. PWA on kokoelma verkon parhaita käytäntöjä [Kapoor] ja pyrkii toimimaan natiivisovelluksen kaltaisesti. Ihannetilanne on sellainen, jossa käyttäjä ei pysty sanomaan onko sovellus natiivisovellus vai verkkosovellus. PWA:n tarkoitus on hämärtää natiivisovelluksen ja web-sovelluksen rajaa. Rajaa halutaan hämärtää siksi, että yleensä sovellusten julkaiseminen sovelluskauppoihin on hidasta, aikaa vievää ja lisäksi vielä maksullista. Kehittäjän ja tilaajan näkökulmasta PWA sovelluksen kehittäminen on siis järkevää. Sovellusta ei tarvitse erikseen ohjelmoida usealle eri mobiilialustalle [Gazdecki], julkaisusykli on nopeampi ja kehittäminen on halvempaa. Sovellus muotoutuu käyttäjän laitteelle alustasta riippumatta, yksi ainoa versio riittää.

Alex Russell määritteli blogikirjoituksessaan PWA:n ominaisuudet seuraavasti. 

Sovelluksen tulee olla:
\begin{itemize}
  \item \textbf{Responsiivinen:} Sovelluksen tulee sopia mille tahansa näytölle koosta ja resoluutiosta riippumatta.
  \item \textbf{Yhteyksistä riippumaton:} Sovelluksen tulee käynnistyä myös Offline-tilassa.
  \item \textbf{Sovelluksen kaltainen:} Sovelluksessa tulee olla käyttöliittymäkehys, sekä sisältöikkuna.
  \item \textbf{Tuore:} Sovelluksen pitää hakea aina verkkoyhteyden ollessa päällä uusin versio käyttäjän huomaamatta.
  \item \textbf{Turvallinen:} Sovellus pitää aina tarjota salattuna Transport Layer Security (TLS) käyttäen.
  \item \textbf{Löydettävä:} Sovelluksen tulee noudattaa W3C yhteisön määrityksiä ja tarjota manifesti, joka määrittää sovelluksen. Manifesti mahdollistaa hakukoneiden löytää sovellus ja erottaa se muista perinteisistä verkkosivuista.
  \item \textbf{Koukuttaa käyttäjän, tai muistuttaa palaamaan:} Sovelluksen tulee olla mahdollista muistuttaa olemassaolostaan esimerkiksi notifikaatioilla ja näin saada käyttäjä palaamaan sovelluksen pariin.
  \item \textbf{Asennettava:} Sovelluksen voi asentaa mobiililaitteen ruudulle pikakuvakkeeksi, jolloin se on nopeasti saatavilla.
\end{itemize}

\subsection{Miksi progressiivia Web-sovelluksia tarvitaan?}
\enlargethispage{5mm}

Tarkastellaan ensiksi millaisia haasteita nykyään natiivi- ja Web-sovelluksissa on.

\begin{itemize}
  \item \textbf{Internetin nopeus.} Internet ei ole kaikkialla maailmassa nopea. noin 60\% maailmasta käyttää yhä 2G verkkoa [Kapoor] ja paikoitellen verkko on niin ruuhkautunut, että sen tiedonsiirtokyky ei vain ole riittävä.
  \item \textbf{Hidas verkkosivun latautuminen.} Verkkosivun tulee latautua tarpeeksi nopeasti. Yhä useammin sivuilla on erilaisia bannereita, multimediaa ja moderneja animaatioita. Jos sovelluksen palvelinpuoli ei ole kunnossa, voi sovellus toimia hitaasti. Tutkimuksen mukaan 53\% käyttäjistä hylkää sivun, mikäli se latautuu ja käyttäytyy liian hitaasti [Kapoor].
  \item \textbf{Kynnys asentaa omalle laitteelle on korkea.} Ihmiset eivät halua asentaa omille laitteilleen sovelluksia [Kapoor]. ComScoren mukaan Keskimääräinen käyttäjä lataa ja asentaa laitteellensa nolla sovellusta kuukaudessa [Perez].
  \item \textbf{Käyttäjän sitouttaminen.} Mobiilikäyttäjät viettävät suurimman osan ajastaan natiivisovelluksissa, mutta verkkosivujen käyttöaste on lähes kolminkertainen. Lisäksi käyttäjät viettävät 80\% ajastaan kolmen tärkeimmän natiivisovelluksen parissa. 
\end{itemize}

PWA pyrkii ratkaisemaan näitä ongelmia. Progressiivisen Web-sovelluksen käyttöön on useita syitä. Tässä muutamia:

\begin{itemize}
  \item \textbf{Nopeus:} PWA tarjoaa välimuistiin tallentamisen, joka mahdollistaa sovelluksen latautumisen välimuistista. Sovelluksen käynnistäminen on siis erityisen nopeaa, vaikka verkkoon ei olisi vielä edes tehty kutsuja.
  \item \textbf{Saumaton käyttökokemus:} PWA tuntuu ja käyttäytyy kuin natiivisovellus. Sovellus on mahdollista asentaa mobiililaitteen kotinäytölle. Sovellus voi lähettää ilmoituksia (push notifications) ja sovellus voi myös hyödyntää laitteen rajapintoja, kuten kameraa, tai mikrofonia. 
  \item \textbf{Luotettava käyttökokemus:} Sovellus voidaan avata myös silloin, kun verkkoyhteyttä ei ole saatavilla. Välimuistiin tallennetun tiedon perusteella viimeisimmät muistissa olevat asiat saadaan esitettyä. 
  \item \textbf{Sitouttava:} Kun sovellukseen voidaan lähettää ilmoituksia, voidaan käyttäjää sitouttaa sovellukseen lähettämällä muistutuksia, tai tärkeitä tietoja. 
\end{itemize}


\subsection{Progressiivisen Web-sovelluksen vaatimukset}

Google on julkaissut Progressiivisille Web-sovelluksille tarkastuslistan, jota noudattamalla sovelluksesta saadaan progressiivinen [Google]. Käydään seuraavaksi listasta läpi minimivaatimukset joiden tulee täyttyä, jotta sovellusta voidaan sanoa progressiiviseksi.

\textbf{Web App Manifest}: Jotta projektista saataisiin sovelluksen kaltainen, tulee sovelluksen juureen määritellä manifest.json tiedosto. Tiedosto pitää sisällään tiedot seuraavista asioista:

\begin{itemize}
  \item Sovelluksen nimi
  \item Sovelluksen teeman väri
  \item Taustaväri
  \item Sovelluksen oletus käyttöasento, joko pysty, tai vaaka
  \item Aloitustiedosto, yleensä index.html tai index.js
  \item Ikonitiedot eri resoluutioissa
\end{itemize}

Kyseessä on tavallinen Json-tiedosto, joka pitää sisällään niin sanottua metatietoa sovelluksesta. Kun selain havaitsee manifest.json tiedoston, se tietää että kyseessä on sovelluksen kaltainen verkkosivu. Tiedostossa määritelty kuvake on se, joka luodaan käyttäjän kotinäytölle asennuspäätöksen tehtäessä. Kun sovellus avataan kuvakkeesta, muuttuu mobiililaitteen statuskenttä sovelluksen teeman väriä vastaavaksi.  

\textbf{Service Workers} on työkalu, joka on koko progressiivisen sovelluksen pohja. Service Worker on myös kokonaan uusi työkalu verkkosovelluksissa. Service Worker on tapahtumapohjainen koodinpätkä, jota ajetaan sovelluksen taustalla. Skripti toimii niinsanottuna proxyna, eli välittäjänä verkon ja sovelluksen välillä. Service Workerin päällimmäinen tarkoitus on toimia välimuistina. Skripti kopioi verkosta haetut tiedot välimuistiin ja seuraavalla kerralla kun käyttäjä pyytää samoja tietoja, ne ladataankin puhelimen välimuistista, jolloin sovelluksen toiminta nopeutuu huomattavasti. Service Workeria hyödyntämällä sovellus voidaan avata myös Offline-tilassa ja näyttää tietoja välimuistista. 

Toinen Service Workerin käyttötapa liittyy notifikaatioihin. Tämä skripti on sovelluksesta irtonainen ja suoritetaan mobiililaitteen taustalla. Jokainen web-selain hallitsee push-notifikaatiot oman push servicensä kautta. Kun käyttäjä antaa selaimelle luvan lähettää ilmoituksia, voidaan sovellus silloin tilata selaimen push palveluun [Googleb]. Tämä luo objektin joka sisältää päätepisteen (endpoint) tilaukselle, joka on eri jokaisessa selaimessa. Lisäksi tilaukseen tarvitaan julkinen avain. Push notifikaatiot lähetetään selaimen tilausosoitteeseen kryptattuna julkisella avaimella. Push-palvelu lähettää lopulta ilmoituksen käyttäjän mobiililaitteelle. Näin ollen sovelluksessa voidaan näyttää notifikaatoita jopa silloin, kun sovellus itsessään on suljettuna. Näin ei ole aikaisemmin voinut tehdä hybridisovelluksissa, kuten esimerkiksi PhoneGapissa tai Cordovassa, joilla web-sovellus paketoidaan natiivisovellukseksi selainkehystä käyttäen.

\textbf{Ikoni, sovelluskuvake}, kun käyttäjä tekee päätöksen asentaa sovellus puhelimeensa, luodaan manifest.json tiedostossa määritelty ikoni käyttäjän mobiililaitteen työpöydälle tai valikkoon. Ikoniksi pitäisi käydä useampi eri formaatti, kunhan vain formaatti on määritelty tiedostoon erikseen. Ikoneita pitää olla useita eri kokoja, jotta resoluutio riittää kaikenkokoisille näytöille.

\textbf{HTTPS salattu liikenne}, jotta sovellus voidaan laskea PWA:ksi, tulee kaikki liikenne lähettää salattuna HTTPS-protokollan ylitse. Salatun liikenteen käyttäminen on nykyisin hyvä ja lähes pakollinen tapa, jotta sovellus voidaan laskea luotettavaksi. Vuodesta 2018 eteenpäin Google on myös rankannut verkkosivuja sen perusteella käyttävätkö ne HTTPS-protokollaa [Eisworth]. Ilman salatun yhteyden käyttämistä sovellusta ei lasketa PWA:ksi ja sen ranking on Googlen haussa huonompi, kuin salattua liikennettä käyttävien sivustojen. 

\subsection{Näyttötilat}

PWA tuo mukanaan niin sanotut näyttötilat, joiden tarkoitus on piilottaa käyttäjältä ylimääräiset valikot ja luoda sovelluksesta näin natiivisovelluksen kaltainen. Näyttötiloja on neljä erilaista [Mozilla]:

\begin{itemize}
  \item \textbf{Fullscreen:} Koko näytön tila, jolloin laitteen koko näyttö on käytössä ja selaimen user agent on piilotettuna.
  \item \textbf{Standalone:} Standalone tilassa sovellus näyttää ja tuntuu omalta sovellukseltaan. Sovellusta voidaan ajaa omassa ikkunassaan ja sillä voi olla oma ikoni käynnistysvalikossa. selaimen käyttöliittymä on piilotettuna, mutta mobiililaitteen omat valikot ovat esillä, kuten tilapalkki. 
  \item \textbf{Minimal-ui:} Minimal-ui tila on sama kuin standalone, mutta mukana on vain minimaalinen määrä käyttöliittymäelementtejä navigointia varten. Käyttöliittymäelementtien määrä riippuu laitteella käytettävästä selaimesta. 
  \item \textbf{Browser:} Selaintila on oletustila, jolloin sovellus aukeaa selaimen välilehdellä, tai uudessa ikkunassa, riippuen selaimesta ja laitealustasta. 
\end{itemize}

\begin{figure}[h]
\begin{center}
\epsfig{figure=nayttotilat.png,  width=0.9\textwidth}
\caption{Näyttötilat vasemmalta oikealle: Browser, standalone / minimal-ui, fullscreen}
\label{Näyttötilat}
\end{center}
\end{figure}
\clearpage

\subsection{Muut teknologiat ja erot}

Vain muutama vuosi takaperin älypuhelimet olivat melko yksinkertaisia. Niillä pystyi korkeintaan selaamaan verkossa tekstiä, linkkejä ja ehkä kuvia. Laitteiden omistajat olivat yleensä liikemiehiä joilla oli jatkuva tarve sähköpostiin, tai sitten henkilöitä jotka halusivat vain uusimmat teknologiat käyttöönsä. Mobiililaitteiden kenttä kuitenkin muuttui täysin Applen julkaistua iPhonen. Applen alkuperäinen idea oli käyttää nimenomaan web-teknologioita [charland2011mobile]. Kuitenkin kolme vuotta julkaisun jälkeen natiivisovellukset ovat ottaneet vallan. Natiivisovelluksissa on kuitenkin ongelma. Jokaiselle laitealustalle täytyy luoda oma sovellus, sillä laitealustat käyttävät pohjalla eri ohjelmointikieliä. Lisäksi ohjelmistojen ylläpito usealle laitteelle on kalliimpaa. 3D-sovelluksissa ja peleissä natiivikielen käyttö saattaa tuoda etuja, mutta hyvin rakennetuissa verkkosovelluksissa suorituskykyeroa on miltei mahdoton huomata [charland2011mobile]. Sovelluskehitystä hankaloittaa lisäksi se, että jokaisella laitteella on oltava oma kehitysympäristö ja työkalut. Rajapinnat ovat erilaiset ja sovelluksen paketointi ei ole yhdenmukaista. Kun sovelluksen ylläpitoon ja kehitykseen täytyy käyttää useampia ympäristöjä se nostaa luonnollisesti sovelluskehityksen kuluja [xanthopoulos2013comparative]. Mobiilisovelluksien kasvava tarve on ajanut yritykset ahdinkoon, sillä samaa sovellusta tulee kehittää usealle laitealustalle [xanthopoulos2013comparative]. Natiivisovelluskehitys olisi järkevintä, mutta sen haittana on että mitään koodista ei voida käyttää muilla alustoilla. Saman sovelluksen joutuu kehittämään alusta alkaen toiselle laitteelle. Loppukäyttäjän näkökulmasta natiivisovellus tarjoaa kuitenkin yleensä parhaan käyttökokemuksen.

Yhteistä kaikille näille teknologioille on se, että natiivisovellus, hybridisovellus, tai React Native sovellus julkaistaan ja jaellaan jonkun sovelluskaupan kautta [xanthopoulos2013comparative]. iOS käyttöjärjestelmällä Apple App Store, Androidilla Google Play, Microsoftilla Windows Phone Store ja BlackBerryllä App World. Jokainen laitevalmistaja omistaa luonnollisesti oman sovelluskauppansa. Monopoliasemassa ovat kuitenkin Android 69,6\% asennuksien määrässä ja toisena iOS 20.9\% asennusmäärällä [xanthopoulos2013comparative]. Sovelluksia kehitettäessä ja julkaistaessa tulee noudattaa käyttöjärjestelmävalmistajien ehtoja ja ohjelmointimalleja. Tästä syystä on muodostunut ilmiö nimeltään pirstoutuminen, sillä sovelluksia tulee kehittää ja ylläpitää usealle alustalle. 

Hybridisovellukset tulivat paikkaamaan tätä pirstoutumista. Hybridisovellusten idea on yksinkertaistaa kehitystyötä ja ylläpitoa, sekä säästää aikaa ja rahaa.  Hybridisovelluksen tarkoituksena on tarjota lähes natiivisovelluksen kaltainen käyttökokemus ja toimia mahdollisimman monella laitteella. “Kirjoita kerran, aja missä vain“ ei oikeastaan päde natiivisovelluksissa. Hybridisovellukset siis kirjoitetaan kerran ja käännetään sen jälkeen mahdollisimman monelle laitteelle. 


Taulukossa 1 on lueteltuna eri mobiililaitteille vaadittavat ohjelmointikielet.

\clearpage

\begin{table}[!ht]
\centering
\begin{small}
\caption{Mobiilikäyttöjärjestelmät ja niiden natiiviohjelmointikieli. [charland2011mobile] }
\begin{tabular}{|L{7cm}|L{7cm}|}
\hline
\textbf{Käyttöjärjestelmä} & 
\textbf{Ohjelmointikieli}
\\ \hline
Apple iOS & 
 C, Objective C
\\ \hline
Google Android & 
Java (Harmony flavored, Dalvik VM) \\ 
\hline
RIM BlackBerry & 
Java (J2ME flavored) \\ 
\hline
Symbian & 
C, C++, Python, HTML/CSS/JS \\ 
\hline
Windows Mobile & 
.NET \\ 
\hline
Window 7 Phone & 
.NET \\ 
\hline
HP Palm webOS & 
HTML/CSS/JS \\ 
\hline
MeeGo & 
C, C++, HTML/CSS/JS \\ 
\hline
Samsung bada & 
C++ \\ 
\hline
\end{tabular}
\label{table:ExampleTable2}
\end{small}
\end{table}


\subsection{Hybridisovellukset}

Jokaisella laitteella on kuitenkin jotain yhteistä. Kaikissa laitteissa on web-selain. Vuonna 2008 iPhoneDevCamp tapahtumassa Eric Oesterle, Rob Ellis ja Brock Whitten [charland2011mobile] esittelivät uuden vallankumouksellisen teknologian. Jokaisella alustalla oli mahdollista käynnistää selain niin sanottuun “Chromeless“ tilaan ja kutsua laitteen natiivirajapintaa JavaScriptin ylitse. Tästä muodostui myöhemmin työkalu nimeltään PhoneGap. Työkalu julkaistiin myöhemmin myös Androidille, BlackBerrylle, sekä muille alustoille. PhoneGapia hyödyntäen oli mahdollista kirjoittaa yleisimpiä web-tekniikoita hyödyntäen sovelluksia, joista oli mahdollista kutsua laitteen natiiveja rajapintoja. PhoneGap kehyksessä on natiivikoodilla kirjoitettuja koodin palasia, jotka välittävät tiedon JavaScript sovellukselle.

Adobe lahjoitti PhoneGap työkalun Apache Software Foundationille ja työkalun nimeksi tuli Cordova [Tung]. Cordovalla tavallisia web-sovelluksia voidaan siis paketoida ja kääntää mobiililaitteille. Cordovan toimintaa voidaan laajentaa erilaisilla lisäosilla “plugins“, joita löytyy esimerkiksi Android alustalle yli 4000 kappaletta [Cordova]. Lisäosia tai laajennuksia hyödyntäen verkkosovelluksesta voidaan kutsua mobiililaitteen natiiveja rajapintoja. Hybridisovellukset eivät siis ole natiivisovelluksia, vaan ne toimivat laitteen Webview-näkymässä web-sovelluksena [bosnic2016development]. Mobiililaitteissa joissa Webview on vanhentunut ei Cordovalla saada täysiä hyötyjä [bosnic2016development]. Ongelmia voi muodostua esimerkiksi suorituskyvyn tai puuttuvien funktioiden muodossa. Hybridisovelluskehitystä tutkivassa artikkelissa Apache Cordovalla käännetty sovellus käytti noin 20\% enemmän prosessoritehoa kuin natiivisovellus [bosnic2016development]. Tulos oli odotettavissa, sillä natiivisovelluksia kehitetään juuri niiden suorituskyvyn takia. Hybridisovellusten etuna on kuitenkin yksi yhtenäinen koodipohja ja ne soveltuvat hyvin yksinkertaisiin sovelluksiin, joissa ei ole raskaita animaatioita tai siirtymäelementtejä. 

Koska Cordovan sovelluksia ajetaan Webview näkymässä, vuonna 2013 Intel aloitti kehittämään Crosswalk nimistä projektia [Crosswalk]. Crosswalk projektin tarkoituksena oli tuoda uusimmat web-selainten ominaisuudet Cordovaan. Vuonna 2017 projekti kuitenkin tuli päätökseensä, sillä PWA sovellukset nostivat päätään ja lisäksi Android käyttöjärjestelmien Webview näkymä päivitettiin jakamaan koodia Chrome selaimen kanssa. Nykyisin Cordovalla käännetyt projektit tukevat siis suoraan uusimpia selainten ominaisuuksia. Hyvin tehtyä hybridisovellusta voi olla vaikea erottaa natiivisovelluksesta [Haikonen]. Koska hybridisovellus on paketoitu natiivisovellukseksi niiden jakelu tapahtuu esimerkiksi Google Play kaupassa, tai Apple Storessa natiivisovellusten tapaan. Hybridisovellusten etuna on kehitysnopeus, sillä samaa koodia voidaan käyttää jokaiselle laitteelle. Ainoastaan lisäosia käytettäessä tulee tarkistaa, että jokaiselle laitealustalle löytyy oikea laajennos. 

Hybridisovellukset ovat siis HTML ja JavaScript pohjaisia sovelluksia, jossa laitealustan tietoja ja ohjelmointikieltä ei välttämättä tarvita ollenkaan. Hybridisovellukset upottavat näkymän natiivin kehyksen sisään. UIWebView iOS laitteille ja WebView Android laitteilla [xanthopoulos2013comparative]. Kuten verkkosovelluksissa, myös hybridisovelluksissa koodi suoritetaan selaimessa, joka lopulta vain paketoidaan sovellukseksi. 

\subsection{React Native}

React Native on Facebookin kehittämä natiivisovelluskehys. React nativella ei tehdä web-sovelluksia, ei hybridisovelluksia, eikä HTML5 sovelluksia. React Nativella rakennetaan natiiveja sovelluksia, joiden käyttöliittymä kasataan JavaScriptillä ja Reactilla [Facebook]. React Nativella on mahdollista kirjoittaa koko sovellus käyttäen Reactia ja JavaScriptiä, tai vain osa ja kirjoittaa loput natiivikoodilla. Esimerkiksi Facebook sovellus toimii React Nativella ja muita React Nativea käyttäviä yhtiöitä ovat esimerkiksi Instagram, Uber ja Skype. Tämä kertoo sen, että teknologia on todettu hyvin toimivaksi ja se soveltuu hyvin vaativiin projekteihin, joissa ei ole varaa heikkoon suorituskykyyn.

React Native eroaa hybridisovelluksista ja web-sovelluksista siten, että kun sovelluksen näkymä renderöidään React Native kutsuu joko Objective C rajapintaa iOS laitteilla, tai Java rajapintaa Android laitteilla [Aggarwal]. Tämä erottaa React Nativen hybridisovelluksista ja muista välimalleista, jotka yleensä renderöivät web perusteisen näkymän. React Native tukee tällä hetkellä iOS ja Android alustoja. Se voisi tukea myös muita käyttöjärjestelmiä, mutta silloin jonkun täytyy koodata puuttuva rajapinta.  

React Nativen etuna on natiivisovelluksen nopeus ja yksi ja sama koodipohja molemmille käyttöjärjestelmille. Sovelluksen kirjoittamiseen kuluu huomattavasti vähemmän aikaa ja rahaa. Sovellus voidaan luoda vain käyttäen yhtä ohjelmointikieltä (JavaScript), eikä ole tarvetta etsiä erikseen iOS tai Android kehittäjää. React Native on siis täysiverinen ohjelmistokehys, jota voi itse laajentaa kirjoittamalla natiivikoodia. Mikäli kehys ei suoraan tue jotain toimintoa, voidaan sellainen kirjoittaa ilman sen kummempia vaatimuksia mitä iOS ja Android alustoilla on.

\subsection{Natiivisovellus}

Android ja iOS alustojen ohjelmointikieli on täysin eri, joten molemmille alustoille tarvitaan oma kehittäjä, omat kehitysympäristöt ja kääntäjät. Androidille julkaistuja sovelluksia jaellaan Google Play kaupassa ja iOS:lle Apple Storessa [Haikonen]. Mikäli sovelluksen mielii kehittää molemille, tai vielä useammalle laitteelle saattavat kehityskustannukset kasvaa suuriksi. Sovelluskehityksen näkökulmasta molemmat alustat ovat hyvin vakaita ja ne ovat olleet käytössä usean vuoden. Tästä on etua, mikäli soveluksen on tarkoitus olla pitkäikäinen.  

Natiivisovelluksen ongelmia on etsiä oikeat kehittäjät, jotka ymmärtävät alustan. Kahden eri koodipohjan ylläpito voi olla haastavaa. Toinen sovelluksista voi esimerkiksi olla edellä toista päivityksissä. Lisäksi käyttöliittymä kirjastot ovat erilaisia. Natiivisovellukseksi suositellaan yleensä sovellusta, joka käyttää paljon laitteen natiiveja rajapintoja. Esimerkiksi yhteystietoja tai kalenteria. Natiivisovelluskehitys soveltuu tietysti myös peleihin parhaan suorituskyvyn takia. 

\subsection{Erot PWA sovellukseen}

PWA sovellus on muista sovelluksista täysin erilainen, sillä sitä ei jaella missään sovelluskaupassa. Sovelluksen löydettävyys tapahtuu esimerkiksi verkon hakukoneilla. PWA sovellus on siis verkkosovellus, joka noudattaa verkon parhaita teknologioita. Sovellusta ei ole pakko asentaa, mutta halutessaan siitä voi luoda pikakuvakkeen laitteen sovellusvalikkoon. PWA:n suurin ongelma toistaiseksi on sen pääsy laitteiden natiiveihin rajapintoihin. PWA sovellus on aina ajan tasalla, sillä se on selainpohjainen sovellus ja uusimmat tiedot käydään hakemassa palvelimelta. PWA sovellus on myös mahdollista kääntää hybridisovellukseksi, mikäli sen haluaa julkaista sovelluskaupassa. Sovelluskaupassa julkaisemiselle ei välttämättä ole kuitenkaan tarvetta. Mikäli esimerkiksi sovelluksen brändi on tarpeeksi hyvä, löytävät käyttäjät sivustolle ilman sovelluskauppoja. Hyvänä esimerkkinä on verkkokauppa.com. Verkkokauppa.comilla ei ole omaa erillistä sovellusta verkkokaupalleen, vaan verkkosivuilla toistamiseen vierailu ehdottaa käyttäjälle sovelluksen asentamista. Kun Verkkokaupan sovelluksen avaa asennetusta kuvakkeesta häviää selaimen käyttöliittymä näkyvistä ja jäljelle jää ikäänkuin Verkkokaupan mobiilisovellus. Verkkokauppa.comilla on siis käytössään PWA sovellus. PWA-mallin käyttäminen Verkkokauppa.comilla on ollut varmasti järkevää, sillä erillisen sovelluksen kehittäminen pelkkää verkkokauppaa varten olisi todella työlästä ja kallista. Verkkokauppa palvelussa ei myöskään ole mitään tarpeita käyttää mobiililaitteen natiiveja rajapintoja. Kaikki kauppaan liittyvät toiminnot saadaan suoritettua verkkosivulla.

PWA ja hybridisovellusten erot alkavat olla melko lähellä toisiaan, sillä ainakin Androidin nykyinen WebView näkymä käyttää taustalla pääosin Chrome selainta [Crosswalk]. Erona Hybridisovelluksella ja PWA mallilla on, että hybridisovelluksesta on laajempi pääsy laitteen rajapintoihin. Hybridisovellus myös paketoidaan tietylle laitealustalle ja julkaistaan laittevalmistajan jakelukanavalla. PWA sovellusta sen sijaan ei tarvitse julkaista missään. Sovellus alkaa ehdottamaan asennusta mikäli käyttäjä vierailee sivustolla useamman kerran. PWA:n etuna on siis esimerkiksi se, että kehittäjien ei tarvitse noudattaa minkään sovelluskaupan käyttöehtoja. Sovelluksen julkaisusta ei myöskään tarvitse maksaa mitään. Esimerkiksi Androidin Google Play kaupan lisenssi maksaa 25 dollaria koko elämäksi ja Applen App Store lisenssi maksaa kehittäjälle 99 dollaria vuodessa, tai 299e dollaria vuodessa yritykselle. PWA sovelluksen etuna voi myös olla löydettävyys. Ihmiset etsivät useimmiten tietoa verkon hakukoneista. Jotta yksittäinen käyttäjä etsisi sovellusta sovelluskaupasta, täytyy brändin tai sovelluksen olla tuttu muuta kautta. 

Yksi suuri etu PWA sovelluksissa on niiden koko. Pinterestin tekemässä case study tutkimuksessa [Osmani] Pinterestin sovelluskaupoissa julkaiseman sovelluksen koko oli Android alustalla noin 10 megatavua ja iOS alustalla jopa 56 megatavua. Pinterestin tekemän PWA muutosten myötä PWA sovelluksen koko oli vain 150 kilotavua. Vaikka Pinterest edelleen jakelee mobiilisovellusta Android ja iOS alustoille, he pystyivät tekemään PWA sovelluksella saman kuin mobiilisovelluksilla, mutta vain murto-osalla sovelluksen koosta. Tämä on käyttäjälle etu, suurta sovellusta ei tarvitse ladata jotta sitä pääsee käyttämään. Sovellusta voi käyttää verkossa heti, ilman että on ladannut yhtään mitään, tai edes tehnyt päätöstä sovelluksen asennuksesta. PWA:n etuna myös normaaliin verkkosivuun on välimuistin hyödyntäminen. Pinterestin suorituskykymittauksen mukaan sovelluksen kääntäminen nopeutui 30\% ja parsiminen 25\% toisella vierailulla.  

\newpage
\section{Tutkimusongelma}

Telia IoT-palvelulla on helppoa seurata huoneilman lämpötila-, kosteus- ja hiilidioksiditasoja. Lisäksi on mahdollista tarkastella kuinka paljon työpisteitä tai neuvotteluhuoneita käytetään. Telio IoT-palvelu on hanke, jonka sovelluskehitys on käynnistetty vuoden 2016 alussa. Sovelluksen alkuperäinen ja nykyinen tarkoitus on pääpiirteittäin pysynyt samana vuosien aikana. Sen avulla on mahdollista parantaa viihtyvyyttä ja tehokkuutta toimiston työympäristössä. Moni viettää suuren osan päivästä sisätiloissa, erityisesti toimistossa. Sisäilman laadulla onkin huomattava vaikutus työhyvinvointiin, terveyteen, työtehokkuuteen, sekä viihtyvyyteen työpaikalla. 

Telia IoT-alustan avulla voi esimerkiksi seurata lämpötilaa ja sen muutoksia. Palvelun avulla voidaan tutkia onko toimistossa esimerkiksi liian kylmä, tai nähdä nousiko lämpötila varastossa liian kuumaksi menemättä itse paikalle. Kosteutta ja hiilidioksiditasoja seuraamalla voidaan päästä jäljille sisäilman muutoksista ja seurata esimerkiksi kokoustilan ilmanlaatua. Liikesensoreilla voidaan laskea työpisteiden, tai neuvotteluhuoneiden käyttöaste. 

IoT-palvelu on verkkosivu, tai selainpohjainen käyttöliittymä IoT-laitteiden tuottaman datan tarkasteluun. Palvelu on ostettavissa ja tilattavissa Telian IoT-sivuilta. Telia on määritellyt, että sovelluksen tulee toimia pääpiirteittäin kaikilla mahdollisilla mobiililaitteilla, sekä vähintään uusimmilla ja yleisimmillä nettiselaimilla. IoT hankkeen tavoitteena oli luoda selkeä käyttöliittymä, jolla seurata huoneilmaa. 

Telia halusi projektista myös mobiilisovelluksen. Yhdessä kehittäjätiimin kanssa suoritettiin lyhyt arviointi erilaisista teknologioista ja vaihtoehdoista. Koska projektin kulut haluttiin pitää kurissa, valittiin toteutusteknologiaksi lopulta PWA-malli sen yksinkertaisuuden ja monimuotoisuuden vuoksi. PWA-mallista ei kuitenkaan ollut vastaavanlaisesta projektista aiempaa kokemusta ja kysymykseksi jäi toisiko se mitään varsinaisia hyötyjä käyttäjille. Ongelmaksi muodostui siis evaluointi miten paljon PWA hyödyttää sovelluksen käyttäjiä.

\subsection{Tutkimuskysymykset}

Olemassa olevan sovelluksen muuttaminen PWA-mallin mukaiseksi toi mukanaan useita kysymyksiä. Ovatko esimerkiksi vanhat projektissa käytössä olevat työkalut riittäviä PWA-mallin luomiseksi? Mitä kaikkea tulisi ottaa huomioon ja mitä oli jo valmiina? Varsinaiset kysymykset koskivat lopulta sitä, mitä etuja PWA tuo mukanaan. Kuinka paljon nopeampi sovellus on käytännössä, ja asentavatko käyttäjät sovellusta puhelimeensa?

Tutkielman tutkimuskysymykset ovat seuraavat:

\begin{itemize}
  \item \textbf{TK1:} Kuinka paljon nopeampi PWA-mallia käyttävä verkkosivu on kuin sivu joka ei hyödynnä PWA:ta?
  \item \textbf{TK2:} Miten olemassa oleva verkkosivu voidaan muokata progressiiviseksi web-sovellukseksi?
  \item \textbf{TK3:} Minkälaisia hyötyjä tai haittoja saadaan käyttämällä PWA-mallia? 
\end{itemize}

\subsection{Tutkimusmenetelmä}

PWA-mallin vaikutuksia käytännössä tarkastellaan Design Science-menetelmällä, eli design-tutkimuksella. Design-tutkimus on tutkimusstrategia, joka pyrkii kehittämään sekä teoriaa että käytäntöä [Pönkä]. Se ei ole metodologia ja sitä voi käyttää niin laadulliseen kuin määrälliseen tutkimukseen. Design-tutkimus on ongelmalähtöistä oppimista, tai tutkivaa oppimista. Olemassa olevan sovelluksen muuttaminen PWA-mallia vastaavaksi oli teoreettinen tehtävä, josta muodostui tutkimuskysymys. 

IoT-sovelluksessa oli myös selkeä lähtökohta, eli olemassa oleva sovellus, jonka rinnalle haluttiin lisäksi myös mobiilisovellus. IoT-projektissa tehtiin selvitys nykyisistä teknologioista ja seuraavaksi sovellus toteutettiin PWA-mallin mukaisesti. Viimeiseksi sovelluksen toimintaa analysoitiin muutoksien jälkeen.

\textbf{Tutkimuksen eteneminen}

Tutkimusprosessin vaiheet ovat pääpiirteittäin seuraavat.

\begin{itemize}
  \item \textbf{Lähtökohta} Tutkimuskysymys mudostui asiakkaan tarpeista muokata olemassa oleva sovellus mobiilisovellukseksi. Millaisia etuja PWA malli tuo mukanaan nykyisille sovelluksen käyttäjille?
  \item \textbf{Tutkimuksen suunnittelu} Sovelluksen arvioimiseksi tarvittiin laatumittarit. Sovelluksesta haluttiin testata nopeutta ja mobiilikäytön määriä. Pääasialliseksi työkaluksi nopeuden mittaamiseksi valittiin Google Lighthouse työkalu, joka antaa sovellukselle PWA-pisteet asteikolla 0-100. Käyttäjämääriä seuraamaan valikoitui Google Analytics.
  \item \textbf{Sovelluksen rakentaminen PWA-mallin mukaiseksi} Sovelluksesta rakennetaan PWA-mallin mukainen ja tarvittavat työkalut liitetään osaksi nykyistä kehityspalettia.
  \item \textbf{Analyysi} Valmista sovellusta mitataan käytännössä ennen ja jälkeen PWA-mallin muutoksia.
  \item \textbf{Tulokset ja johtopäätökset} Mittaustulosten jälkeen sovelluksen eri vaiheista voidaan julkaista tulokset ja johtopäätökset. Kuinka paljon nopeampi sovellus on PWA-mallin myötä? Kuinka paljon sovelluksen build aika kasvoi?
\end{itemize}

\newpage
\section{Tekninen toteutus}

Projektin laitteet toimittaa ruotsalainen Yanzi. Telian asiakkaille tarjoamaan pakettiin kuuluu 4G-tukiasema ja lisäksi 10-12 sensoria asiakkaan valitsemasta paketista riippuen. Tukiasema käyttää 4G verkkoa datan toimittamisessa pilveen. Tukiaseman mukana toimitetaan myös 4G sim-kortti. Näin asiakkaan ei tarvitse huolehtia laitteiden liittämisestä verkkoon, vaan pelkästään yksi pistorasiapaikka virransaantiin riittää. Tukiasemassa on myös pieni akku, jolla laite pysyy käynnissä noin 8 tuntia hätätapauksia tai sähkökatkoksia varten. Lisäksi tukiasemassa on pieni muisti, johon data voidaan säilöä siihen asti, kunnes verkkoyhteys on taas saatavilla. Kun verkkoyhteys palaa jälleen tukiasemaan lähetetään muistiin säilötty data palvelimelle. Näin dataa ei hävitetä vaikka verkkoyhteyttä ei olisikaan. Tämä mahdollistaa paljon uusia käyttökohteita ja tapoja. Palvelua on esimerkiksi testattu valtamerilaivalla, jossa verkkoyhteys on poikki useamman viikon. Myös kaikki liikenne palvelimen ja tukiaseman välillä on salattua.

Sensorit saavat virtansa kahdesta AA paristosta. Yanzi lupaa sensoreiden käyttöajaksi noin 10 vuotta kahdella paristolla. Sensorit yhdistetään tukiasemaan, josta data lähetetään aina lopulta palvelimelle. Yhdessä sensorissa voi olla useampi mittapiste. Esimerkiksi yksi sensori voi mitata lämpötilaa, kosteutta ja ilmanpainetta samanaikaisesti. 

Tukiasemaan on mahdollista liittää useita sensoreita. Myös verkon kantavuutta on mahdollista kasvattaa erillisillä toistimilla. Näin koko toimiston alue saadaan katettua. 

Sensorit lähettävät mittaustulokset tukiasemalle, josta data lähetetään salattuna palvelimelle. Cumulocityn palvelun mukana tulevaa rajapintaa hyödyntäen IoT käyttöliittymän data haetaan JavaScriptillä. Application Programming Interface, lyhyesti API, eli ohjelmointirajapinta tarjoaa sovelluksessa tarvittavat tiedot käyttöliittymälle. Esimerkiksi käyttäjät, laitteet, data ja kaikki palveluun liittyvä tieto saadaan haettua APIa vasten. 

\begin{figure}[h]
\begin{center}
\epsfig{figure=yanzi_gateway.jpg,  width=0.5\textwidth}
\caption{Yanzi 4G tukiasema ilman antenneja. Kuva: yanzi.se}
\label{Yanzi tukiasema}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
\epsfig{figure=yanzi_sensor.jpg,  width=0.5\textwidth}
\caption{Yanzi comfort sensori, joka mittaa: lämpötilaa, kosteutta, ilmanpainetta, äänenvoimakkuutta, hiilidioksiditasoja ja haihtuvia orgaanisia yhdisteitä. Kuva: yanzi.se}
\label{Yanzi sensori}
\end{center}
\end{figure}
\clearpage

\subsection{IoT Dashboard}

Telian IoT palvelussa tietokannan, sekä taustapalvelut tarjoaa saksalainen Cumulocity GmbH, Dusseldorfista. Cumulocityn toimittaa projektin rajapinnan ja Yanzin laitteet tuottavat datan. Projektin tarkoituksena oli luoda helppokäyttöinen käyttöliittymä jota voidaan myydä eteenpäin Telian asiakkaille. Myös Cumulocity toimittaa palvelun mukana kattavan hallintapaneelin, sekä työpöytänäkymän. Sovelluksen käyttö kuitenkin osoittautui lopulta hankalaksi. Tämän seurauksena Telia käynnisti vuoden 2016 alussa projektin helposta käyttöliittymästä IoT laitteille. 

Projektin teknologiaksi valikoitui Cumulocityn kehittäjäpaketin mukana toimitettava AngularJS:n versio 1.3. AngularJS on Googlen ylläpitämä avoimen lähdekoodin JavaScript-ohjelmistokehys, joka avustaa yksisivuisten sovellusten kehittämisessä ja käytössä [jain2015angularjs]. AngularJS:n tavoite on lisätä selainpohjaisiin sovelluksiin tuki MVC-arkkitehtuurille, jonka avulla sivustojen kehitys ja testaus helpottuu. 

MVC-arkkitehtuurilla tarkoitetaan suunnittelumallia, jossa näkymä, malli ja ohjain on jaettu omiksi osioikseen [deacon2009model]. Model, eli malli on ikäänkuin tietomalli, joka ratkoo pellin alla olevia ongelmia. Mallin ei tarvitse olla tietoinen ulkomaailmasta. View, eli näkymä taas voi olla käyttöliittymä, rajapinta tai komentoriviohjelma. Controller, eli ohjain taas kontrolloi näkymää. Ohjain käsittelee syötteet ja näkymä tulosteet, kun malli huolehtii datasta. 

\begin{figure}[h]
\begin{center}
\epsfig{figure=iotlaitteet.PNG,  width=0.9\textwidth}
\caption{Miten IoT palvelu toimii yksinkertaisuudessaan. Kuva: Telian dokumentaatio}
\label{IoT arkkitehtuuri}
\end{center}
\end{figure}

\subsection{Työkalut}

Nykyiset JavaScript pohjaiset käyttöliittymät ovat erittäin monimutkaisia. Koska kyseessä on pelkästään selaimella toimiva käyttöliittymä, on projektia laajennettu vuosien aikana useilla kirjastoilla ja sen ympärille on tuotu mukaan myös kehitystä helpottavia työkaluja. Tässä niistä muutamia. 

\textbf{Grunt} on automaatiotyökalu. Gruntin tarkoitus on tehdä toistuvia tehtäviä automaattisesti kehittäjän puolesta. Grunt toimii sovelluksen tärkeimpänä työkaluna, mutta pelkkä Grunt ei yksistään ole riittävä työkalu projektin tarpeille. Grunt huolehtii esimerkiksi sovelluksen kääntämisestä, paketoinnista, kirjoitusvirheiden tarkastamisesta, kuvien pakkaamisesta, sekä web-palvelimen käynnistämisestä. 

\textbf{Eslint} on avoimen lähdekoodin projekti, joka on aloitettu vuonna 2013. Eslintin tarkoitus on toimia koodin tarkkailijana. Eslinttiin voi liittää lukuisia eri liitännäisiä, jotta koodista saa juuri kehittäjälle mieleisen näköistä. Eslint esimerkiksi pitää huolen siitä, että koodilohkot on sisennetty kahdella välilyönnillä ja lohko päättyy aina puolipisteeseen. Mikäli kehittäjä ei noudata Eslinttiin kirjoitettuja sääntöjä, ei sovellusta käännetä ja kehittäjälle annetaan virheilmoitus virheellisestä syntaksista. Eslintin avulla koodia pyritään yhdenmukaistamaan, riippumatta siitä kuinka monta kehittäjää sovellusta on ollut tekemässä. 

\textbf{Yarn} on riippuvuuksien hallinta työkalu. Yarn toimii pohjana projektille. Yarnin avulla kaikki kehityksen aikaiseen toimintaan liittyvät skriptit ladataan kehittäjän koneelle. Myös sovelluksessa tarvittavat riippuvuudet ladataan Yarnilla. Yarn on Facebookin kehittäjien luoma työkalu. Sen tarkoitus on yhdenmukaistaa riippuvuuksien hallintaa, jolloin jokaisella kehittäjällä olisi käytössään juuri sama versio kyseisestä paketista mikä projektille on määritelty. Yarn valittiin projektin riippuvuuksien hallinta työkaluksi lähinnä siksi, että projektin kehitystyön aikana siirryttiin Bower nimisestä Front-End riippuvuuksien hallinta työkalusta pois. Yarn osaa automaattisesti asentaa Bower riippuvuuksia ja Bowerin sivuilla on suositeltu Yarnia sen korvaajaksi. 

\textbf{Less}, Leaner Style Sheets on laajennustyökalu perinteiselle CSS kielelle. Less tuo mukanaan muutamia hyödyllisiä laajennuksia, esimerkiksi muuttujat, operaatiot ja sisennykset. Muuttujilla voidaan esimerkiksi määrittää sovelluksen taustaväri, jonka jälkeen vaihtamalla muuttujan väriä saadaan sovelluksen taustaväri vaihtumaan jokaisella sivulla. Tyylien sisennyksellä taas on mahdollista kohdistaa tyylit vain tietyn muuttujan alle. Esimerkiksi hiiren hover efekti voidaan laittaa suoraan alkuperäisen tyylin sisälle, ilman että sitä varten tarvitsee luoda uutta riviä.

\textbf{Babel} on uuden sukupolven JavaScript kääntäjä. Babel mahdollistaa kirjoitettavan koodin olevan tuoreinta mahdollista JavaScript syntaksia. Babelin avulla JavaScript käännetään vanhojen selaimien ymmärtämään JavaScript muotoon. Babelia on myös mahdollista laajentaa liitännäisillä.

\textbf{Bootstrap} on maailman suosituin käyttöliittymä kirjasto, jota käyttämällä on helppoa luoda responsiivisia, mobiili edellä kulkevia projekteja. Kirjasto tuo mukanaan esimerkiksi responsiivisen Grid systeemin ja lukuisia käyttövalmiita komponentteja, kuten kuvakarusellin ja tyylitellyt taulukot. 

\textbf{Projektin rakentamisessa} Grunt työkalu huolehtii projektin kasaamisesta ja riippuvuuksien paketoimisesta hyödyntäen edellä mainittuja kirjastoja. Grunt vastaa esimerkiksi seuraavista tehtävistä: Ensimmäisen tehtävänä Grunt käynnistää web-palvelimen projektissa määriteltyyn porttiin. Aina kun sovelluksen koodi tallennetaan, käynnistyy Gruntissa sarja komentoja automaattisesti. Ensiksi koodi käydään läpi Eslint työkalulla, joka huolehtii että koodi noudattaa tiettyjä kirjotuskäytäntöjä. Esimerkiksi koodilohkot tulee olla sisennetty kahdella välilyönnillä ja lohkojen lopussa tulee olla puolipiste. Jos näitä ei noudata, kääntäjä antaa virheilmoituksen, eikä sovellus käänny. Seuraavaksi koodi käännetään Babel nimisen työkalun avulla selaimen ymmärtämään JavaScript formaattiin. Kun JavaScript on selaimen ymmärtämässä muodossa, lisätään Angular kehykselle ominaiset annotaatiot, eli riippuvuudet. Sitten kaikki scriptit paketoidaan yhdeksi kokonaisuudeksi, bundleksi, jonka jälkeen koodi minifoidaan ja siirretään kansioon, jossa on käynnissä web-palvelin. Minifoinnilla tarkoitetaan koodin pienentämistä, esimerkiksi kaikki ylimääräiset välilyönnit ja merkit poistetaan, jotta tiedostosta tulee mahdollisimman pieni.

JavaScript-koodin toimenpiteiden jälkeen CSS-tyylitiedostot käännetään .LESS formaatista selaimen ymmärtämään .CSS muotoon. Kaikki tyylitiedostot paketoidaan myös yhdeksi kokonaisuudeksi ja sitten ne minifoidaan. Lisäksi suoritetaan lukuisia muita toimenpiteitä, projektin kaikki kuvat pakataan, kolmannen osapuolen skriptit käydään läpi, paketoidaan ja liitetään projektiin.

\subsection{PWA:n käyttöönotto projektissa}

Telian alkuperäinen tarkoitus oli laajentaa IoT projektin käyttöliittymää myös mobiililaitteille. Projektissa tehtiin nopea katsaus nykyisistä teknologioista ja lopulta päädyttiin tekemään sovelluksesta PWA-mallin mukainen. Android ja IOS sovellusten haittapuolena olisi ollut kokonaan uusien kehittäjien haaliminen, sekä usean koodin ylläpitäminen. Hybridisovellukselle ei myöskään nähty tarvetta sen hitauden takia. IoT Dashboard sovelluksessa ei ollut tarvetta päästä käsiksi puhelimen natiiveihin rajapintoihin, kuten kalenteriin, tai yhteystietoihin, joten PWA malli oli luonnollinen valinta. Lisäksi osa PWA-mallin vaiheista oli jo täytettynä. Palvelua tarjotaan Telian asiakkaille salattuna HTTPS-protokollan ylitse, sovellus on responsiivinen Bootstrap kirjaston ansiosta ja sovellus käyttää tarpeeksi moderneja työkaluja, jotta siitä oli mahdollista tehdä PWA. Telian kanssa päädyttiin yhteisymmärryksessä PWA malliin. 

PWA-mallin kartoitus alkoi siihen tarvittavilta asioilta. Ensiksi sovellukseen luotiin projektiin sopiva sovelluskuvake ja nimi Web App Manifestiin. Seuraava vaihe, eli Service Workerin lisääminen oli isompi ja haastavampi kokonaisuus. Sovellusta päätettiin laajentaa Googlen tarjoamalla Workbox CLI työkalulla. Workbox on NodeJS pohjainen komentoriviohjelma, jolla on helppoa luoda Service Worker nykyiseen olemassa olevaan projektiin. Lisäksi ohjelma tarjoaa käteviä komentoja, joilla toimintaa voidaan mukauttaa omaan projektiin sopivaksi. Workbox asennettiin projektiin käyttämällä Yarnia.

Seuraavaksi Workboxin käyttöönotossa huomattiin, että Workbox ei ole tuettuna Grunt työkalussa, sillä Grunt on liian vanha. Workboxia on kuitenkin mahdollista ajaa erikseen myös NodeJS skripteillä, joten Grunt työkalua laajennettiin grunt-run nimisellä paketilla, joka mahdollistaa komentojen ajamisen Gruntissa. 

Grunt-run työkalu lisättiin myös Yarnia käyttämällä. Asennuksen jälkeen Gruntiin luotiin Run tehtävä, jonka tarkoitus oli ajaa Workbox skriptit. Tärkeää run komennossa on liittää argumenteiksi “inject:manifest“ [Googlec], jolloin ohjelma tietää liittää lopulliseen Service Worker tiedostoon kaikki tiedostot, jotka pitää lisätä välimuistiin. Näin jokaista tiedostoa tai polkua ei tarvitse kirjoittaa itse. Riittää että konfiguraatiotiedostossa on määritelty välimuistiin tallennettavien tiedostojen päätteet. Injektointikomento on Workboxin mukana tuleva komento.

\begin{lstlisting}[
     language=JavaScript,
     gobble=4,
     frame=single
   ]
    module.exports = {
      options: {},
      generatesw: {
        cmd: './node_modules/workbox-cli/build/bin.js',
        args: ['inject:manifest']
      }
    };
\end{lstlisting}

Kun Grunt on ajanut sovelluksen rakentamiseen liittyvät tehtävät, ajaa se lopussa run tehtävän, joka taas ajaa Workbox skriptin. Skripti käyttää projektin juureen generoitua Service Worker konfiguraatiotiedostoa, joka saatiin alunperin käyttämällä Workboxissa toimitettua asennusvelhoa. Workboxin asennusvelho on automaattinen työkalu konfiguraation luomiseen. Konfiguraatiossa määritellään esimerkiksi mistä kansiosta tiedostoja otetaan mukaan Service Workeriin ja millä tiedostopäätteellä olevat tiedostot lasketaan mukaan. Esimerkkinä IoT projektin Service Worker konfiguraatio

\begin{lstlisting}[
     language=JavaScript,
     gobble=4,
     frame=single
   ]
    module.exports = {
      “globDirectory“: “dist/“,
      “globPatterns“: [
        “**/*.{css,otf,ttf,eot,woff,woff2,svg,png,html,js,json}“
      ],
      “swSrc“: “./src/js/service-worker.js“,
      “swDest“: “./dist/sw.js“,
      “globIgnores“: [
        “../workbox-cli-config.js“,
        “vendor/bowerbundle.js“
      ]
    };
\end{lstlisting}

Projektissa on käsin kirjoitettu Service Worker pohja, joka on määritetty konfiguraatiotiedostossa. Tähän varsinaiseen Service Worker tiedostoon Workbox osaa konfiguraation pohjalta liittää tarvittavat tiedostot. Alla pala käsinkirjoitettua Service Workeria, jota Workbox laajentaa automaattisesti injektiokomennolla.

\begin{lstlisting}[
     language=JavaScript,
     gobble=4,
     frame=single
   ]
    workboxSW.precache([]);
    
    const cacheOneWeekStrategy = workboxSW.strategies.cacheFirst({
      cacheName: 'cdn-cache',
      cacheExpiration: {
        maxEntries: 20,
        maxAgeSeconds: 7 * 24 * 60 * 60, // one week
      },
      cacheableResponse: {
        statuses: [0, 200],
      },
    });
    
    workboxSW.router.registerRoute(
      /https:\/\/fonts.googleapis.com\/(.*)/,
      cacheOneWeekStrategy
    );
    
    workboxSW.router.registerRoute(
      '/',
      workboxSW.strategies.networkFirst()
    );
\end{lstlisting}

Service Workerissa on määritelty workboxSW.precache([]); funktio, jonka parametrina on tyhjä taulukko. Taulukkoon Workbox laajentaa konfiguraatiossa mainitut tiedostot, jotta ne voidaan ottaa Service Workerin cachessa talteen. Service Workeriin on myös määritelty yhden viikon cache strategia ja esimerkiksi Googlen fontit on lisätty tähän yhden viikon strategiaan. Fontit eivät päivity kovin usein ja siksi on hyödyllistä laittaa niille hieman pidempi cache. Itse varsinaiselle sovellukselle taas on laitettu strategiaksi “network first“, eli verkko ensin. Koska sovellus tarvitsee käytännössä aina verkkoyhteyden datan hakemiseksi, ei ole järkevää asettaa strategiaksi cachea, vaan käyttäjälle halutaan aina näyttää ensiksi verkosta saatavilla oleva uusin tieto. Vasta verkkoyhteyden ollessa poissa käytöstä, voidaan cachesta näyttää tietoja. 

Manifestin toimintaa sovelluksessa voitiin tarkastella Google-Chrome selaimen kehittäjäkonsolista sovellusvalikon alta löytyvältä Manifest välilehdeltä. Välilehdeltä selviää heti toimiiko manifesti oletetulla tavalla. Mikäli virheitä ilmenee, ne ilmoitetaan tällä sivulla. Sovelluksen identiteetti tiedoissa tulee lukea manifestin vaatimuksissa määritellyt kentät: sovelluksen nimi, sekä lyhytnimi. Presentaatio kohdassa tulee olla määriteltynä sovelluksen käynnistys osoite, teeman väri, sovelluksen orientaatio mobiililaitteella, sekä näyttömuoto. Ikoni kentissä tulee olla sovelluksen ikoni, joka näytetään käyttäjän mobiililaitteella asennuksen jälkeen. Ikoneita tulee olla useammassa eri resoluutiossa. 

\begin{figure}[h]
\begin{center}
\epsfig{figure=manifest_console.PNG,  width=0.9\textwidth}
\caption{Manifest.json tiedosto Google-Chrome kehittäjäkonsolissa.}
\label{Manifest.json}
\end{center}
\end{figure}
\clearpage

Google-Chromen kehittäjäkonsolin sovellusvälilehdeltä löytyy myös Service Worker ikkuna, josta voidaan tarkistaa Service Workerin asentuminen. Välilehdeltä selviää Service Workerin lähdeskripti, sekä tila. Mikäli Service Worker on tilassa “activated and running“ on se asentunut oikein ja käytössä. Service Workerin yhteyteen on myös liitetty valinnat “Offline“ “Update on reload“ ja “Bypass for network“ täpät. Update on reload ja Bypass for network onkin järkevää asettaa päälle kun sovellusta ollaan kehittämässä. Muuten sovellus saattaa näyttää kehittäjälle vanhaa välimuistissa olevaa tietoa. Täppien toiminta on loogista, Service Worker päivitetään aina sivuston latautuessa uudestaan “Update on reload“ täpän ollessa valittuna ja välimuisti saadaan ohitettua “Bypass for network“ täpällä.

Mikäli Manifest ja Service Worker ovat kunnossa, voidaan sovelluksen toimintaa seuraavaksi tarkastella Google-Chromen audit työkaluilla.

\begin{figure}[h]
\begin{center}
\epsfig{figure=serviceworker_console.PNG,  width=0.9\textwidth}
\caption{Service Workerin asetukset Google-Chromen kehittäjäkonsolissa.}
\label{Service Worker}
\end{center}
\end{figure}

\subsection{Kommunikaatio palvelimen kanssa}

\subsection{Deployment}


\clearpage
\section{Arviointi}

PWA:n käyttöönotossa esiintyi muutamia ongelmia projektin aikana. Projektin työkalut olivat vanhentuneet, joten ensimmäinen varsinainen ongelma oli yhteensopivuusongelma Service Worker työkalun käytössä. Työkalujen kanssa tehtiin jonkin verran töitä, jotta ne saatiin pelaamaan yhteen. Toinen kehityksen aikana ilmennyt ongelma oli sovelluksen näyttäytyminen välimuistista kun Service Worker oli saatu käyttöön. Google Chromen kehittäjäkonsolissa on Service Worker välilehdellä täpät “update on reload“ ja “Bypass for network“ jotka ruksattiin käyttöön. Näin kehittäjä näkee aina uusimmat muutokset selaimessaan. Muutoin koodiin tehdyillä muutoksilla ei välttämättä olisi vaikutusta, sillä Service Worker näyttäisi tiedostoja ja koodia välimuistista. 

Kolmas haaste liittyi Lighthouse työkalun mittauksiin. Nykyisessä sovelluksessa on paljon koodia jota ei ajeta ohjelman käynnistyessä. Tästä syystä Lighthousen auditointityökalu antoi huonot suorituskykypisteet sovellukselle. Koodien pakkaamiseen tehtiin joitakin muutoksia työkalujen käyttömahdollisuuksien mukaan ja tilannetta saatiin hieman parannettua. Myös tietokantakyselyitä koitettiin vähentää. Kyselyiden vähentäminen on kuitenkin haastavaa palvelussa, joka perustuu reaaliaikaiseen dataan. 

\clearpage
\section{Yhteenveto}


\nocite{*}
% yksi näistä tai ...
%\bibliographystyle{plain}
%\bibliographystyle{acm}
\bibliographystyle{ieeetr}

% ... tai tämä 
%\bibliographystyle{apalike}

\clearpage
\bibliography{lahteet}

\lastpage

\appendices

\end{document}
